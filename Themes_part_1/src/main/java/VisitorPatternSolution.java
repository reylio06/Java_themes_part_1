/*
/*
Note: In this problem you must NOT generate any output on your own. Any such solution will be considered as being
against the rules and its author will be disqualified. The output of your solution must be generated by the
uneditable code provided for you in the solution template.

An important concept in Object-Oriented Programming is the open/closed principle, which means writing code that is
open to extension but closed to modification. In other words, new functionality should be added by writing an
extension for the existing code rather than modifying it and potentially breaking other code that uses it. This
challenge simulates a real-life problem where the open/closed principle can and should be applied.

A Tree class implementing a rooted tree is provided in the editor. It has the following publicly available methods:

getValue(): Returns the value stored in the node.
getColor(): Returns the color of the node.
getDepth(): Returns the depth of the node. Recall that the depth of a node is the number of edges between the node
and the tree's root, so the tree's root has depth 0 and each descendant node's depth is equal to the depth of its
parent node +1.
In this challenge, we treat the internal implementation of the tree as being closed to modification, so we cannot
directly modify it; however, as with real-world situations, the implementation is written in such a way that it
allows external classes to extend and build upon its functionality. More specifically, it allows objects of the
TreeVis class (a Visitor Design Pattern) to visit the tree and traverse the tree structure via the accept method.

Part I: Implement Three Different Visitors
Each class has three methods you must write implementations for:

getResult(): Return an integer denoting the result, which is different for each class:

The SumInLeavesVisitor implementation must return the sum of the values in the tree's leaves only.
The ProductRedNodesVisitor implementation must return the product of values stored in all red nodes, including
leaves, computed modulo 10^9 + 7. Note that the product of zero values is equal to 1.
The FancyVisitor implementation must return the absolute difference between the sum of values stored in the tree's
non-leaf nodes at even depth and the sum of values stored in the tree's green leaf nodes. Recall that zero is an even
 number.
visitNode(TreeNode node): Implement the logic responsible for visiting the tree's non-leaf nodes such that the
getResult method returns the correct result for the implementing class' visitor.

visitLeaf(TreeLeaf leaf): Implement the logic responsible for visiting the tree's leaf nodes such that the getResult
method returns the correct result for the implementing class' visitor.

Part II: Read and Build the Tree
Read the n-node tree, where each node is numbered from 1 to n. The tree is given as a list of node values (x1, x2, ..., xn), a list of
node colors (c1, c2, ..., cn), and a list of edges. Construct this tree as an instance of the Tree class. The tree is always rooted
at node number 1.

Your implementations of the three visitor classes will be tested on the tree you built from the given input.

Sample Input

5
4 7 2 5 12
0 1 0 0 1
1 2
1 3
3 4
3 5
Sample Output

24
40
15

 */

package main.java;
import java.util.ArrayList;
import java.io.*;
import java.util.*;
import java.text.*;
import java.math.*;
import java.util.regex.*;

import java.util.ArrayList;
import java.util.Scanner;

public class VisitorPatternSolution {
    public static VisitorPatternTree solve() {
        //read the tree from STDIN and return its root as a return value of this function

        // Solution
        // Create scanner object to read input from keyboard
        Scanner sc = new Scanner(System.in);

        // Read number of nodes n
        int n = sc.nextInt();

        // Read array representing values of each node
        int[] vals = new int[n];

        // Read node values
        for(int i=0; i<n; i++){
            vals[i]= sc.nextInt();

        }
        // Read array representing colors of nodes
        VisitorPatternColor[] colors = new VisitorPatternColor[n];

        // Read node colors
        for(int i=0; i<n; i++){
            colors[i]= sc.nextInt()==1? VisitorPatternColor.GREEN:VisitorPatternColor.RED;
        }

        // Create map to store edges between nodes
        Map<Integer, Set<Integer>> nodeEdges = new HashMap<>();

        // Read edges and build tree structure
        for(int i=0; i<n-1; i++){
            int u = sc.nextInt();
            int v = sc.nextInt();

            // Add edges to the map
            if(!nodeEdges.containsKey(u)){
                nodeEdges.put(u,new HashSet<Integer>());
            }
            if(!nodeEdges.containsKey(v)){
                nodeEdges.put(v,new HashSet<Integer>());
            }
            nodeEdges.get(u).add(v);
            nodeEdges.get(v).add(u);
        }

        // Create map to store index of each node in tree
        Map<VisitorPatternTreeNode, Integer> nodeIndexMap = new HashMap<>();

        // Create list to store parent nodes
        List<VisitorPatternTreeNode> parents = new ArrayList<>();

        // Create root node
        VisitorPatternTreeNode root = new VisitorPatternTreeNode(vals[0],colors[0],0);
        nodeIndexMap.put(root,1);
        parents.add(root);

        // Build tree by traversing through nodes and leaves
        while(!parents.isEmpty()){
            List<VisitorPatternTreeNode> nextLevelParents = new ArrayList<>();
            for(VisitorPatternTreeNode node : parents){
                int depth = node.getDepth();
                int parentIndex = nodeIndexMap.get(node);

                for(int childIndex: nodeEdges.get(parentIndex)){

                    // Remove parent reference from the edges
                    nodeEdges.get(childIndex).remove(parentIndex);

                    if(!nodeEdges.get(childIndex).isEmpty()){
                        // Create a new TreeNode and add it as a child
                        VisitorPatternTreeNode child = new VisitorPatternTreeNode(vals[childIndex-1], colors[childIndex-1],depth+1);
                        nextLevelParents.add(child);
                        nodeIndexMap.put(child, childIndex);
                        node.addChild(child);
                    }else{
                        // Create a new TreeLeaf and add it as a child
                        VisitorPatternTreeLeaf leaf = new VisitorPatternTreeLeaf(vals[childIndex-1], colors[childIndex-1],depth+1);
                        node.addChild(leaf);
                    }
                }
            }
            parents = nextLevelParents;
        }

        // Close scanner
        sc.close();

        // Return root of the tree
        return root;
    }
    // End of Solution

    public static void main(String[] args) {
        VisitorPatternTree root = solve();
        VisitorPatternSumInLeavesVisitor vis1 = new VisitorPatternSumInLeavesVisitor();
        VisitorPatternProductOfRedNodesVisitor vis2 = new VisitorPatternProductOfRedNodesVisitor();
        VisitorPatternFancyVisitor vis3 = new VisitorPatternFancyVisitor();

        root.accept(vis1);
        root.accept(vis2);
        root.accept(vis3);

        int res1 = vis1.getResult();
        int res2 = vis2.getResult();
        int res3 = vis3.getResult();

        System.out.println(res1);
        System.out.println(res2);
        System.out.println(res3);
    }
}